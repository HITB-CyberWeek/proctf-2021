/* This file is auto-generated by brotoc.
 * It's like protoc, but much more cooler. */
#include "broto.hpp"

#include <cstring>
#include <memory>
#include <stdexcept>
#include <string>
#include <tuple>
#include <vector>

namespace brotobuf {

InputStream::InputStream(const std::vector<unsigned char>::iterator &begin,
                         const std::vector<unsigned char>::iterator &end) {
  if (end - begin > 10000) {
    throw std::out_of_range("Too large message, can't deserialize it");
  }
  this->_iterator = begin;
  this->_end = end;
}

unsigned char InputStream::read_byte() {
  if (!this->has_next()) {
    throw std::out_of_range("Input stream reached its end");
  }
  return *(this->_iterator++);
}

std::tuple<InputStream::iterator, InputStream::iterator>
InputStream::read_chunk(size_t count) {
  if (this->_end - this->_iterator < (long long)count) {
    throw std::out_of_range("Input stream reached its end");
  }
  auto start_iterator = this->_iterator;
  this->_iterator += count;
  return {start_iterator, this->_iterator};
}

bool InputStream::has_next() const { return this->_iterator != this->_end; }

OutputStream::OutputStream() { buffer = std::vector<unsigned char>(); }

void OutputStream::write(unsigned char c) { buffer.push_back(c); }

void OutputStream::write(const std::vector<unsigned char> &&data) {
  buffer.insert(buffer.end(), data.begin(), data.end());
}

std::vector<unsigned char> OutputStream::get() const { return buffer; }

void _AbstractMessage::_serialize_varint(unsigned long long variable,
                                         OutputStream &stream) const {
  unsigned long long value = variable;
  do {
    unsigned char last_bits = value & 0x7f;
    value >>= 7;
    if (value) {
      last_bits |= 1 << 7;
    }
    stream.write(last_bits);
  } while (value);
}

void _AbstractMessage::_serialize_string(const std::string &variable,
                                         OutputStream &stream) const {
  this->_serialize_varint(variable.length(), stream);
  for (auto &c : variable) {
    stream.write((unsigned char)c);
  }
}

unsigned long long _AbstractMessage::_deserialize_varint(InputStream &stream) {
  unsigned long long result = 0;
  unsigned char byte = stream.read_byte();
  size_t shift = 0;
  while (byte & (1 << 7)) {
    result |= ((unsigned long long)(byte & 0x7f)) << shift;
    byte = stream.read_byte();
    shift += 7;
    if (shift > 56) {
      throw std::out_of_range("Too large varint in the stream");
    }
  }
  result |= ((unsigned long long)byte) << shift;
  return result;
}

void _AbstractMessage::_deserialize_string(std::string &variable,
                                           InputStream &stream) {
  unsigned long long length = this->_deserialize_varint(stream);
  variable.resize(length);
  for (size_t i = 0; i < length; i++) {
    variable[i] = stream.read_byte();
  }
}

bool _AbstractMessage::_debug_memory_logs_enabled() const {
  const auto env = getenv("BROTOBUF_DEBUG_MEMORY");
  if (!env) {
    return false;
  }
  return strncmp(env, "1", 1) == 0;
}

} // namespace brotobuf
