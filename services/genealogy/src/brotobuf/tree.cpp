/* This file is auto-generated by brotoc.
 * It's like protoc, but much more cooler. */
#include "tree.hpp"
#include "broto.hpp"
#include "link.hpp"
#include "person.hpp"

#include <memory>
#include <stdexcept>
#include <string>
#include <tuple>
#include <vector>

namespace brotobuf {
GenealogyTree::GenealogyTree() {
  this->title = "";
  this->description = "";
  this->owners = std::vector<unsigned long long>();
  this->person = Person();
  this->links = std::vector<Link>();
}
void GenealogyTree::serialize(OutputStream &stream) const {
  this->serialize(std::move(stream));
}
void GenealogyTree::serialize(OutputStream &&stream) const {
  printf("== Starting serialization of GenealogyTree at %p\n", this);
  this->serialize_id(stream);
  this->serialize_title(stream);
  this->serialize_description(stream);
  this->serialize_owners(stream);
  this->serialize_person(stream);
  this->serialize_links(stream);
}
void GenealogyTree::deserialize(InputStream &stream) {
  this->deserialize(std::move(stream));
}
void GenealogyTree::deserialize(InputStream &&stream) {
  printf("== Starting deserialization of GenealogyTree at %p\n", this);
  this->owners = std::vector<unsigned long long>();
  this->links = std::vector<Link>();

  while (stream.has_next()) {
    unsigned long long field_index = this->_deserialize_varint(stream);
    switch (field_index) {

    case 0:
      printf("Writing to %p->id\n", this);
      this->id = this->_deserialize_varint(stream);
      break;
    case 1:
      printf("Writing to %p->title\n", this);
      this->_deserialize_string(this->title, stream);
      break;
    case 2:
      printf("Writing to %p->description\n", this);
      this->_deserialize_string(this->description, stream);
      break;
    case 3:
      if (this->owners.empty()) {
        printf("Allocating %p->owners for 10 elements of %ld bytes = %ld = "
               "0x%lx\n",
               this, sizeof(unsigned long long),
               10 * sizeof(unsigned long long),
               10 * sizeof(unsigned long long));
        this->owners.resize(10);
        this->_owners_iterator = this->owners.begin();
      }
      printf("Writing to %p->owners[%ld]\n", this,
             this->_owners_iterator - this->owners.begin());
      *(this->_owners_iterator) = this->_deserialize_varint(stream);
      this->_owners_iterator++;
      break;
    case 4:
      printf("Writing to %p->person\n", this);
      this->_deserialize_object<Person>(this->person, stream);
      break;
    case 5:
      if (this->links.empty()) {
        printf(
            "Allocating %p->links for 10 elements of %ld bytes = %ld = 0x%lx\n",
            this, sizeof(Link), 10 * sizeof(Link), 10 * sizeof(Link));
        this->links.resize(10);
        this->_links_iterator = this->links.begin();
      }
      printf("Writing to %p->links[%ld]\n", this,
             this->_links_iterator - this->links.begin());
      this->_deserialize_object<Link>(*(this->_links_iterator), stream);
      this->_links_iterator++;
      break;
    }
  }

  this->owners.resize(this->_owners_iterator - this->owners.begin());
  printf("Shrinking %p->owners for %ld elements, freed %ld bytes\n", this,
         owners.size(), owners.capacity() * sizeof(unsigned long long));
  this->owners.shrink_to_fit();
  this->links.resize(this->_links_iterator - this->links.begin());
  printf("Shrinking %p->links for %ld elements, freed %ld bytes\n", this,
         links.size(), links.capacity() * sizeof(Link));
  this->links.shrink_to_fit();
}
void GenealogyTree::serialize_id(OutputStream &stream) const {
  if (this->id == 0)
    return;
  this->_serialize_varint(0, stream);
  this->_serialize_varint(this->id, stream);
}
void GenealogyTree::serialize_title(OutputStream &stream) const {
  if (this->title == "")
    return;
  this->_serialize_varint(1, stream);
  this->_serialize_string(this->title, stream);
}
void GenealogyTree::serialize_description(OutputStream &stream) const {
  if (this->description == "")
    return;
  this->_serialize_varint(2, stream);
  this->_serialize_string(this->description, stream);
}
void GenealogyTree::serialize_owners(OutputStream &stream) const {
  if (this->owners.size() == 0)
    return;
  if (this->owners.size() > 10) {
    throw std::out_of_range(
        "Can not serialize object: owners is too long, max length is 10");
  }
  for (auto &element : this->owners) {
    this->_serialize_varint(3, stream);
    this->_serialize_varint(element, stream);
  }
}
void GenealogyTree::serialize_person(OutputStream &stream) const {
  if (0)
    return;
  this->_serialize_varint(4, stream);
  this->_serialize_object<Person>(this->person, stream);
}
void GenealogyTree::serialize_links(OutputStream &stream) const {
  if (this->links.size() == 0)
    return;
  if (this->links.size() > 10) {
    throw std::out_of_range(
        "Can not serialize object: links is too long, max length is 10");
  }
  for (auto &element : this->links) {
    this->_serialize_varint(5, stream);
    this->_serialize_object<Link>(element, stream);
  }
}
} // namespace brotobuf