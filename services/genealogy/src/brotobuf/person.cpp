/* This file is auto-generated by brotoc.
 * It's like protoc, but much more cooler. */
#include "person.hpp"
#include "broto.hpp"

#include <memory>
#include <stdexcept>
#include <string>
#include <tuple>
#include <vector>

namespace brotobuf {
Person::Person() {
  this->name = "";
  this->parents = std::vector<Person>();
}
void Person::serialize(OutputStream &stream) const {
  this->serialize(std::move(stream));
}
void Person::serialize(OutputStream &&stream) const {
  printf("== Starting serialization of Person at %p\n", this);
  this->serialize_birth_date(stream);
  this->serialize_death_date(stream);
  this->serialize_name(stream);
  this->serialize_parents(stream);
}
void Person::deserialize(InputStream &stream) {
  this->deserialize(std::move(stream));
}
void Person::deserialize(InputStream &&stream) {
  printf("== Starting deserialization of Person at %p\n", this);
  this->parents = std::vector<Person>();

  while (stream.has_next()) {
    unsigned long long field_index = this->_deserialize_varint(stream);
    switch (field_index) {

    case 0:
      printf("Writing to %p->birth_date\n", this);
      this->birth_date = this->_deserialize_varint(stream);
      break;
    case 1:
      printf("Writing to %p->death_date\n", this);
      this->death_date = this->_deserialize_varint(stream);
      break;
    case 2:
      printf("Writing to %p->name\n", this);
      this->_deserialize_string(this->name, stream);
      break;
    case 3:
      if (this->parents.empty()) {
        printf("Allocating %p->parents for 10 elements of %ld bytes = %ld = "
               "0x%lx\n",
               this, sizeof(Person), 10 * sizeof(Person), 10 * sizeof(Person));
        this->parents.resize(10);
        this->_parents_iterator = this->parents.begin();
      }
      printf("Writing to %p->parents[%ld]\n", this,
             this->_parents_iterator - this->parents.begin());
      this->_deserialize_object<Person>(*(this->_parents_iterator), stream);
      this->_parents_iterator++;
      break;
    }
  }

  this->parents.resize(this->_parents_iterator - this->parents.begin());
  printf("Shrinking %p->parents for %ld elements, freed %ld bytes\n", this,
         parents.size(), parents.capacity() * sizeof(Person));
  this->parents.shrink_to_fit();
}
void Person::serialize_birth_date(OutputStream &stream) const {
  if (this->birth_date == 0)
    return;
  this->_serialize_varint(0, stream);
  this->_serialize_varint(this->birth_date, stream);
}
void Person::serialize_death_date(OutputStream &stream) const {
  if (this->death_date == 0)
    return;
  this->_serialize_varint(1, stream);
  this->_serialize_varint(this->death_date, stream);
}
void Person::serialize_name(OutputStream &stream) const {
  if (this->name == "")
    return;
  this->_serialize_varint(2, stream);
  this->_serialize_string(this->name, stream);
}
void Person::serialize_parents(OutputStream &stream) const {
  if (this->parents.size() == 0)
    return;
  if (this->parents.size() > 10) {
    throw std::out_of_range(
        "Can not serialize object: parents is too long, max length is 10");
  }
  for (auto &element : this->parents) {
    this->_serialize_varint(3, stream);
    this->_serialize_object<Person>(element, stream);
  }
}
} // namespace brotobuf