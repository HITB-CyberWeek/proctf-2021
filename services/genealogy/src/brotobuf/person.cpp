/* This file is auto-generated by brotoc.
 * It's like protoc, but much more cooler. */
#include "person.hpp"
#include "broto.hpp"

#include <memory>
#include <optional>
#include <stdexcept>
#include <string>
#include <tuple>
#include <vector>

namespace brotobuf {
Person::Person() {
  this->title = "";
  this->first_name = "";
  this->middle_name = "";
  this->last_name = "";
  this->photo_url = "";
  this->parents = std::vector<Person>();
}
void Person::serialize(OutputStream &stream) const {
  this->serialize(std::move(stream));
}
void Person::serialize(OutputStream &&stream) const {
  if (this->_debug_memory_logs_enabled()) {
    printf("Starting serialization of Person at %p\n", this);
  }
  this->serialize_birth_date(stream);
  this->serialize_death_date(stream);
  this->serialize_title(stream);
  this->serialize_first_name(stream);
  this->serialize_middle_name(stream);
  this->serialize_last_name(stream);
  this->serialize_photo_url(stream);
  this->serialize_parents(stream);
}
void Person::deserialize(InputStream &stream) {
  this->deserialize(std::move(stream));
}
void Person::deserialize(InputStream &&stream) {
  if (this->_debug_memory_logs_enabled()) {
    printf("== Starting deserialization of Person at %p\n", this);
  }
  this->parents = std::vector<Person>();

  while (stream.has_next()) {
    unsigned long long field_index = this->_deserialize_varint(stream);
    switch (field_index) {

    case 0:
      if (this->_debug_memory_logs_enabled()) {
        printf("Deserializing data to birth_date->birth_date\n");
      }
      this->birth_date = this->_deserialize_varint(stream);
      break;
    case 1:
      if (this->_debug_memory_logs_enabled()) {
        printf("Deserializing data to death_date->death_date\n");
      }
      this->death_date = this->_deserialize_varint(stream);
      break;
    case 2:
      if (this->_debug_memory_logs_enabled()) {
        printf("Deserializing data to title->title\n");
      }
      this->_deserialize_string(this->title, stream);
      break;
    case 3:
      if (this->_debug_memory_logs_enabled()) {
        printf("Deserializing data to first_name->first_name\n");
      }
      this->_deserialize_string(this->first_name, stream);
      break;
    case 4:
      if (this->_debug_memory_logs_enabled()) {
        printf("Deserializing data to middle_name->middle_name\n");
      }
      this->_deserialize_string(this->middle_name, stream);
      break;
    case 5:
      if (this->_debug_memory_logs_enabled()) {
        printf("Deserializing data to last_name->last_name\n");
      }
      this->_deserialize_string(this->last_name, stream);
      break;
    case 6:
      if (this->_debug_memory_logs_enabled()) {
        printf("Deserializing data to photo_url->photo_url\n");
      }
      this->_deserialize_string(this->photo_url, stream);
      break;
    case 7:
      if (this->parents.empty()) {
        this->parents.resize(2);
        if (this->_debug_memory_logs_enabled()) {
          printf("Allocated %ld bytes for parent->parents at %p\n",
                 2 * sizeof(Person), parents.data());
        }
        this->_parents_iterator = this->parents.begin();
      }
      if (this->_debug_memory_logs_enabled()) {
        printf("Deserializing data to parent->parents[%ld]\n",
               this->_parents_iterator - this->parents.begin());
      }
      this->_deserialize_object<Person>(*(this->_parents_iterator), stream);
      this->_parents_iterator++;
      break;
    }
  }

  this->parents.resize(this->_parents_iterator - this->parents.begin());
  if (this->_debug_memory_logs_enabled()) {
    printf("Shrinking parent->parents, freeing %ld bytes at %p\n",
           parents.capacity() * sizeof(Person), parents.data());
  }
  this->parents.shrink_to_fit();
}
void Person::serialize_birth_date(OutputStream &stream) const {
  if (this->birth_date == 0)
    return;
  this->_serialize_varint(0, stream);
  this->_serialize_varint(this->birth_date, stream);
}
void Person::serialize_death_date(OutputStream &stream) const {
  if (this->death_date == 0)
    return;
  this->_serialize_varint(1, stream);
  this->_serialize_varint(this->death_date, stream);
}
void Person::serialize_title(OutputStream &stream) const {
  if (this->title == "")
    return;
  this->_serialize_varint(2, stream);
  this->_serialize_string(this->title, stream);
}
void Person::serialize_first_name(OutputStream &stream) const {
  if (this->first_name == "")
    return;
  this->_serialize_varint(3, stream);
  this->_serialize_string(this->first_name, stream);
}
void Person::serialize_middle_name(OutputStream &stream) const {
  if (this->middle_name == "")
    return;
  this->_serialize_varint(4, stream);
  this->_serialize_string(this->middle_name, stream);
}
void Person::serialize_last_name(OutputStream &stream) const {
  if (this->last_name == "")
    return;
  this->_serialize_varint(5, stream);
  this->_serialize_string(this->last_name, stream);
}
void Person::serialize_photo_url(OutputStream &stream) const {
  if (this->photo_url == "")
    return;
  this->_serialize_varint(6, stream);
  this->_serialize_string(this->photo_url, stream);
}
void Person::serialize_parents(OutputStream &stream) const {
  if (this->parents.size() == 0)
    return;
  if (this->parents.size() > 2) {
    throw std::out_of_range(
        "Can not serialize object: parents is too long, max length is 2");
  }
  for (auto &element : this->parents) {
    this->_serialize_varint(7, stream);
    this->_serialize_object<Person>(element, stream);
  }
}
} // namespace brotobuf