/* This file is auto-generated by brotoc.
 * It's like protoc, but much more cooler. */
#ifndef _BROTO_HPP_
#define _BROTO_HPP_

#include <memory>
#include <stdexcept>
#include <string>
#include <tuple>
#include <vector>

namespace brotobuf {

class InputStream {
  using iterator = std::vector<unsigned char>::iterator;

public:
  InputStream(const iterator &begin, const iterator &end);
  unsigned char read_byte();
  std::tuple<iterator, iterator> read_chunk(size_t count);
  bool has_next() const;

private:
  iterator _iterator;
  iterator _end;
};

class OutputStream {
public:
  OutputStream();
  void write(unsigned char c);
  void write(const std::vector<unsigned char> &&data);
  std::vector<unsigned char> get() const;

private:
  std::vector<unsigned char> buffer;
};

class _AbstractMessage {
protected:
  void _serialize_varint(unsigned long long variable,
                         OutputStream &stream) const;
  void _serialize_string(const std::string &variable,
                         OutputStream &stream) const;
  template <typename T>
  void _serialize_object(const T &variable, OutputStream &stream) const {
    auto temp_stream = OutputStream();
    variable.serialize(temp_stream);
    auto data = temp_stream.get();

    this->_serialize_varint(data.size(), stream);
    stream.write(std::move(data));
  }
  unsigned long long _deserialize_varint(InputStream &stream);
  void _deserialize_string(std::string &variable, InputStream &stream);
  template <typename T>
  void _deserialize_object(T &variable, InputStream &stream) {
    auto length = this->_deserialize_varint(stream);
    auto [from, to] = stream.read_chunk(length);
    auto temp_stream = InputStream(from, to);

    variable.deserialize(temp_stream);
  }
  bool _debug_memory_logs_enabled() const;
};

} // namespace brotobuf

#endif